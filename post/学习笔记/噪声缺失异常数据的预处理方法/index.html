<!doctype html>
<html lang="en-us">
  <head>
    <title>噪声、缺失、异常数据的预处理方法 // 清晨的阳光的博客</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.80.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="清晨的阳光" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://chacefoo.github.io/css/main.min.68e582a4d4ed824d6b7e3b5b37cae47eb3779bd631046379d0e68b38230cc3e2.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="噪声、缺失、异常数据的预处理方法"/>
<meta name="twitter:description" content="一、噪声的处理 ​	噪声(noise)是被测量的变量的随机误差或方差。我们可以使用基本的数据统计描述技术(例如，盒图或者散点图)和数据可视化方法来识别可能代表噪声的离群点。
1. 分箱(bining) 分箱方法通过考察数据的“近邻”(即周围的值)来光滑有序的数据值。这些有序的值被分布到一些“捅”或箱中。由于分箱方法考察近邻的值，因此它进行局部的光滑。
如上图所示，数据首先排序并被划分到大小为3的等频的箱中。对于用箱均值光滑，箱中每一个值都被替换为箱中的均值。类似的，可以使用用箱中位数光滑或者用箱边界光滑等等。
2. 回归(regression) 可以用一个函数拟合数据来光滑数据。这种技术称之为回归。线性回归涉及找出拟合两个属性(或变量)的“最佳”直线，使得一个属性可以用来预测另一个。多元线性回归是线性回归的扩充，其中涉及的属性多余两个，并且数据拟合到一个多维曲面。
3. 离群点分析(outlier analysis) ​	可以通过如聚类来检测离群点。聚类将类似的值组织成群或“簇”。直观地，落在簇集合之外的值被视为离群点。
二、缺失的处理 1. 用平均值、中值、分位数、众数、随机值等替代。  如果预计该变量对于学习模型效果影响不大，可以对unknown值赋众数，这里认为变量都对学习模型有较大影响，效果一般，因为等于人为增加了噪声，不建议采取此法。 数值型的话，均值和近邻或许是更好的方法。做成哑变量更适合分类、顺序型变量。
2. 用其他变量做预测模型来算出缺失变量。  效果比方法1略好。有一个根本缺陷，如果其他变量和缺失变量无关，则预测的结果无意义。如果预测结果相当准确，则又说明这个变量是没必要加入建模的。一般情况下，介于两者之间。 可以使用数据完整的行作为训练集，以此来预测缺失值。又由于sklearn的模型只能处理数值变量，需要先将分类变量数值化，然后进行预测。 一般使用KNN, Matrix completion等方法预测。
3. 把变量映射到高维空间。  比如性别，有男、女、缺失三种情况，则映射成3个变量：是否男、是否女、是否缺失。连续型变量也可以这样处理。比如Google、百度的CTR预估模型，预处理时会把所有变量都这样处理，达到几亿维。这样做的好处是完整保留了原始数据的全部信息、不用考虑缺失值、不用考虑线性不可分之类的问题。缺点是计算量大大提升。 而且只有在样本量非常大的时候效果才好，否则会因为过于稀疏，效果很差。 连续变量这么map岂不会产生超多纬数的data？这种也叫one hot. 把取值变成离散特征。
4. 用特殊值标记 引入虚拟变量(dummy variable)来表征是否有缺失，是否有补全。
5. 忽略该行数据。  有一些模型，如随机森林，自身能够处理数据缺失的情况，在这种情况下不需要对缺失数据做任何的处理，这种做法的缺点是在模型的选择上有局限。
6. 删除。 最简单最直接的方法，很多时候也是最有效的方法，这种做法的缺点是可能会导致信息丢失。对于unknown值数量较少的变量可以选择删除。删除有缺失数据的样本，删除有过多缺失数据的特征。
三、异常的处理 1. 删除 ​	这种方法简单易行，但缺点也很明显，首先我们经常会遇到的情况是样本数很少，这种删除会造成样本的不足，其次，直接删除的样本数很多，也可能会改变变量的原有分布，从而造成统计模型不够稳定。
2. 暂且保留，待结合整体模型综合分析 通常我们观测到的异常值，有时在对于整个模型而言，其异常性质并没有观测到的明显，因此最好综合分析一下，像回归分析，我们经常利用残差分布信息来判断模型优劣，残差有没有超出经验范围（&#43;3标准差），呈现什么分布等，另外对于整个模型而言，会有一些指标像Mahalanobis、Cook&rsquo;s、协方差比率等可以提供某条观测或整体的拟合信息，这些指标也会提示分析人员的异常值信息。如果对于整个模型而言，并不是很明显时，建议保留。
3. 使用均值或其他统计量取代 ​	这不失为一种折中的方法，大部分的参数方法是针对均值来建模的，用均值取代，实际上克服了丢失样本的缺陷，但却丢失了样本“特色”，可以说是不大不小的错误。当然如果是时序数据，用于取代的统计量，可供选择的范围就会多一些，可以针对序列选择合适的统计量取代异常值，也较少存在上述问题。
4. 将其视为缺失值，利用统计模型填补 该方法的好处是可以利用现有变量的信息，对异常值（缺失值）填补。不过这里最好要视该异常值（缺失值）的特点而定，例如需视是完全随机缺失、随机缺失还是非随机缺失的不同情况而定。
5. 不做过多处理，根据其性质特点，使用稳健模型加以修饰 如果按参数性质分的话，可以将稳健方法分为参数、非参和半参3种情况，这大致与通常的关于参数的假设、优点一样。
6. 使用抽样技术或模拟技术，接受更合理的标准误等信息 ​	抽样样本所计算出的均值的标准误，一般来说会更合理，这可以有效应对异常值的影响，但前提是原始样本量不能太少（小于10），小样本的结果不够稳定。另外模拟技术可以利用先验分布特征和样本信息来构建事后预测的概率分布，进行事后模拟，这种技术现在发展的很好，在异常值的应对中，表现良好。"/>

    <meta property="og:title" content="噪声、缺失、异常数据的预处理方法" />
<meta property="og:description" content="一、噪声的处理 ​	噪声(noise)是被测量的变量的随机误差或方差。我们可以使用基本的数据统计描述技术(例如，盒图或者散点图)和数据可视化方法来识别可能代表噪声的离群点。
1. 分箱(bining) 分箱方法通过考察数据的“近邻”(即周围的值)来光滑有序的数据值。这些有序的值被分布到一些“捅”或箱中。由于分箱方法考察近邻的值，因此它进行局部的光滑。
如上图所示，数据首先排序并被划分到大小为3的等频的箱中。对于用箱均值光滑，箱中每一个值都被替换为箱中的均值。类似的，可以使用用箱中位数光滑或者用箱边界光滑等等。
2. 回归(regression) 可以用一个函数拟合数据来光滑数据。这种技术称之为回归。线性回归涉及找出拟合两个属性(或变量)的“最佳”直线，使得一个属性可以用来预测另一个。多元线性回归是线性回归的扩充，其中涉及的属性多余两个，并且数据拟合到一个多维曲面。
3. 离群点分析(outlier analysis) ​	可以通过如聚类来检测离群点。聚类将类似的值组织成群或“簇”。直观地，落在簇集合之外的值被视为离群点。
二、缺失的处理 1. 用平均值、中值、分位数、众数、随机值等替代。  如果预计该变量对于学习模型效果影响不大，可以对unknown值赋众数，这里认为变量都对学习模型有较大影响，效果一般，因为等于人为增加了噪声，不建议采取此法。 数值型的话，均值和近邻或许是更好的方法。做成哑变量更适合分类、顺序型变量。
2. 用其他变量做预测模型来算出缺失变量。  效果比方法1略好。有一个根本缺陷，如果其他变量和缺失变量无关，则预测的结果无意义。如果预测结果相当准确，则又说明这个变量是没必要加入建模的。一般情况下，介于两者之间。 可以使用数据完整的行作为训练集，以此来预测缺失值。又由于sklearn的模型只能处理数值变量，需要先将分类变量数值化，然后进行预测。 一般使用KNN, Matrix completion等方法预测。
3. 把变量映射到高维空间。  比如性别，有男、女、缺失三种情况，则映射成3个变量：是否男、是否女、是否缺失。连续型变量也可以这样处理。比如Google、百度的CTR预估模型，预处理时会把所有变量都这样处理，达到几亿维。这样做的好处是完整保留了原始数据的全部信息、不用考虑缺失值、不用考虑线性不可分之类的问题。缺点是计算量大大提升。 而且只有在样本量非常大的时候效果才好，否则会因为过于稀疏，效果很差。 连续变量这么map岂不会产生超多纬数的data？这种也叫one hot. 把取值变成离散特征。
4. 用特殊值标记 引入虚拟变量(dummy variable)来表征是否有缺失，是否有补全。
5. 忽略该行数据。  有一些模型，如随机森林，自身能够处理数据缺失的情况，在这种情况下不需要对缺失数据做任何的处理，这种做法的缺点是在模型的选择上有局限。
6. 删除。 最简单最直接的方法，很多时候也是最有效的方法，这种做法的缺点是可能会导致信息丢失。对于unknown值数量较少的变量可以选择删除。删除有缺失数据的样本，删除有过多缺失数据的特征。
三、异常的处理 1. 删除 ​	这种方法简单易行，但缺点也很明显，首先我们经常会遇到的情况是样本数很少，这种删除会造成样本的不足，其次，直接删除的样本数很多，也可能会改变变量的原有分布，从而造成统计模型不够稳定。
2. 暂且保留，待结合整体模型综合分析 通常我们观测到的异常值，有时在对于整个模型而言，其异常性质并没有观测到的明显，因此最好综合分析一下，像回归分析，我们经常利用残差分布信息来判断模型优劣，残差有没有超出经验范围（&#43;3标准差），呈现什么分布等，另外对于整个模型而言，会有一些指标像Mahalanobis、Cook&rsquo;s、协方差比率等可以提供某条观测或整体的拟合信息，这些指标也会提示分析人员的异常值信息。如果对于整个模型而言，并不是很明显时，建议保留。
3. 使用均值或其他统计量取代 ​	这不失为一种折中的方法，大部分的参数方法是针对均值来建模的，用均值取代，实际上克服了丢失样本的缺陷，但却丢失了样本“特色”，可以说是不大不小的错误。当然如果是时序数据，用于取代的统计量，可供选择的范围就会多一些，可以针对序列选择合适的统计量取代异常值，也较少存在上述问题。
4. 将其视为缺失值，利用统计模型填补 该方法的好处是可以利用现有变量的信息，对异常值（缺失值）填补。不过这里最好要视该异常值（缺失值）的特点而定，例如需视是完全随机缺失、随机缺失还是非随机缺失的不同情况而定。
5. 不做过多处理，根据其性质特点，使用稳健模型加以修饰 如果按参数性质分的话，可以将稳健方法分为参数、非参和半参3种情况，这大致与通常的关于参数的假设、优点一样。
6. 使用抽样技术或模拟技术，接受更合理的标准误等信息 ​	抽样样本所计算出的均值的标准误，一般来说会更合理，这可以有效应对异常值的影响，但前提是原始样本量不能太少（小于10），小样本的结果不够稳定。另外模拟技术可以利用先验分布特征和样本信息来构建事后预测的概率分布，进行事后模拟，这种技术现在发展的很好，在异常值的应对中，表现良好。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chacefoo.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%99%AA%E5%A3%B0%E7%BC%BA%E5%A4%B1%E5%BC%82%E5%B8%B8%E6%95%B0%E6%8D%AE%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/" />
<meta property="article:published_time" content="2021-01-15T21:14:03+08:00" />
<meta property="article:modified_time" content="2021-01-15T21:14:03+08:00" />

    <script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

  </head>
  <body>
    <header class="app-header">
      <a href="https://chacefoo.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="清晨的阳光" /></a>
      <h1>清晨的阳光的博客</h1>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/">Home</a>
      </nav>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/chacefoo" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">噪声、缺失、异常数据的预处理方法</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jan 15, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <h2 id="一噪声的处理">一、噪声的处理</h2>
<p>​	噪声(noise)是被测量的变量的随机误差或方差。我们可以使用基本的数据统计描述技术(例如，盒图或者散点图)和数据可视化方法来识别可能代表噪声的离群点。</p>
<h3 id="1-分箱bining">1. 分箱(bining)</h3>
<p>分箱方法通过考察数据的“近邻”(即周围的值)来光滑有序的数据值。这些有序的值被分布到一些“捅”或箱中。由于分箱方法考察近邻的值，因此它进行局部的光滑。</p>
<p>如上图所示，数据首先排序并被划分到大小为3的等频的箱中。对于用箱均值光滑，箱中每一个值都被替换为箱中的均值。类似的，可以使用用箱中位数光滑或者用箱边界光滑等等。</p>
<h3 id="2-回归regression">2. 回归(regression)</h3>
<p>可以用一个函数拟合数据来光滑数据。这种技术称之为回归。线性回归涉及找出拟合两个属性(或变量)的“最佳”直线，使得一个属性可以用来预测另一个。多元线性回归是线性回归的扩充，其中涉及的属性多余两个，并且数据拟合到一个多维曲面。</p>
<h3 id="3-离群点分析outlier-analysis">3. 离群点分析(outlier analysis)</h3>
<p>​	可以通过如聚类来检测离群点。聚类将类似的值组织成群或“簇”。直观地，落在簇集合之外的值被视为离群点。</p>
<h2 id="二缺失的处理">二、缺失的处理</h2>
<h3 id="1-用平均值中值分位数众数随机值等替代">1. 用平均值、中值、分位数、众数、随机值等替代。</h3>
<p>  如果预计该变量对于学习模型效果影响不大，可以对unknown值赋众数，这里认为变量都对学习模型有较大影响，效果一般，因为等于人为增加了噪声，不建议采取此法。
  数值型的话，均值和近邻或许是更好的方法。做成哑变量更适合分类、顺序型变量。</p>
<h3 id="2-用其他变量做预测模型来算出缺失变量">2. 用其他变量做预测模型来算出缺失变量。</h3>
<p>  效果比方法1略好。有一个根本缺陷，如果其他变量和缺失变量无关，则预测的结果无意义。如果预测结果相当准确，则又说明这个变量是没必要加入建模的。一般情况下，介于两者之间。
  可以使用数据完整的行作为训练集，以此来预测缺失值。又由于sklearn的模型只能处理数值变量，需要先将分类变量数值化，然后进行预测。
  一般使用KNN, Matrix completion等方法预测。</p>
<h3 id="3-把变量映射到高维空间">3. 把变量映射到高维空间。</h3>
<p>  比如性别，有男、女、缺失三种情况，则映射成3个变量：是否男、是否女、是否缺失。连续型变量也可以这样处理。比如Google、百度的CTR预估模型，预处理时会把所有变量都这样处理，达到几亿维。这样做的好处是完整保留了原始数据的全部信息、不用考虑缺失值、不用考虑线性不可分之类的问题。缺点是计算量大大提升。
  而且只有在样本量非常大的时候效果才好，否则会因为过于稀疏，效果很差。
  连续变量这么map岂不会产生超多纬数的data？这种也叫one hot. 把取值变成离散特征。</p>
<h3 id="4-用特殊值标记">4. 用特殊值标记</h3>
<p>引入虚拟变量(dummy variable)来表征是否有缺失，是否有补全。</p>
<h3 id="5-忽略该行数据">5. 忽略该行数据。</h3>
<p>  有一些模型，如随机森林，自身能够处理数据缺失的情况，在这种情况下不需要对缺失数据做任何的处理，这种做法的缺点是在模型的选择上有局限。</p>
<h3 id="6-删除">6. 删除。</h3>
<p>最简单最直接的方法，很多时候也是最有效的方法，这种做法的缺点是可能会导致信息丢失。对于unknown值数量较少的变量可以选择删除。删除有缺失数据的样本，删除有过多缺失数据的特征。</p>
<h2 id="三异常的处理">三、异常的处理</h2>
<h3 id="1-删除">1. 删除</h3>
<p>​	这种方法简单易行，但缺点也很明显，首先我们经常会遇到的情况是样本数很少，这种删除会造成样本的不足，其次，直接删除的样本数很多，也可能会改变变量的原有分布，从而造成统计模型不够稳定。</p>
<h3 id="2-暂且保留待结合整体模型综合分析">2. 暂且保留，待结合整体模型综合分析</h3>
<p>通常我们观测到的异常值，有时在对于整个模型而言，其异常性质并没有观测到的明显，因此最好综合分析一下，像回归分析，我们经常利用残差分布信息来判断模型优劣，残差有没有超出经验范围（+3标准差），呈现什么分布等，另外对于整个模型而言，会有一些指标像Mahalanobis、Cook&rsquo;s、协方差比率等可以提供某条观测或整体的拟合信息，这些指标也会提示分析人员的异常值信息。如果对于整个模型而言，并不是很明显时，建议保留。</p>
<h3 id="3-使用均值或其他统计量取代">3. 使用均值或其他统计量取代</h3>
<p>​	这不失为一种折中的方法，大部分的参数方法是针对均值来建模的，用均值取代，实际上克服了丢失样本的缺陷，但却丢失了样本“特色”，可以说是不大不小的错误。当然如果是时序数据，用于取代的统计量，可供选择的范围就会多一些，可以针对序列选择合适的统计量取代异常值，也较少存在上述问题。</p>
<h3 id="4-将其视为缺失值利用统计模型填补">4. 将其视为缺失值，利用统计模型填补</h3>
<p>该方法的好处是可以利用现有变量的信息，对异常值（缺失值）填补。不过这里最好要视该异常值（缺失值）的特点而定，例如需视是完全随机缺失、随机缺失还是非随机缺失的不同情况而定。</p>
<h3 id="5-不做过多处理根据其性质特点使用稳健模型加以修饰">5. 不做过多处理，根据其性质特点，使用稳健模型加以修饰</h3>
<p>如果按参数性质分的话，可以将稳健方法分为参数、非参和半参3种情况，这大致与通常的关于参数的假设、优点一样。</p>
<h3 id="6-使用抽样技术或模拟技术接受更合理的标准误等信息">6. 使用抽样技术或模拟技术，接受更合理的标准误等信息</h3>
<p>​	抽样样本所计算出的均值的标准误，一般来说会更合理，这可以有效应对异常值的影响，但前提是原始样本量不能太少（小于10），小样本的结果不够稳定。另外模拟技术可以利用先验分布特征和样本信息来构建事后预测的概率分布，进行事后模拟，这种技术现在发展的很好，在异常值的应对中，表现良好。</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
    
  </body>
</html>
